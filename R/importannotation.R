#
# Copyright 2019 Luis Valledor / Laura Lamelas
# Last revision 28.09.2020
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' @name importannotation
#' @title Import annotations from Excel (xlsx or xsl) or text (txt) files
#' @description This function is used to import annotations (descriptions) of
#' the variables present in the dataset.
#' @usage importannotation()
#' @details This function creates a dataframe containing the description of the variables
#' which can be further used in pRocessomics univariate
#' and multivariate statistical analysis.
#' These descriptions can come from Mapman categories or another source.
#' For further details about Mapman categories see \url{https://mapman.gabipd.org/app/mercator}
#' For Custom annotation files, there is a main required structure.
#' Annotation tables should have four columns: variable identifier or
#' accession, as named in the datasets; variable description,
#' as character; bin/group/pathway code, as numeric; and variable
#' bin/group/pathway name, as character.
#' Annotation tables must be in txt, xls, or xlsx format
#' This function will keep only the variables present in the datasets, due to this fact is
#' recommended to use this function after data pre-processing and filtering steps.
#' The information introduced will be available to include in graphics and tables.
#' Please go to \url{https://github.com/Valledor/pRocessomics/} for more information and examples.
#' @return A data frame ,pRoannot class object, containing the description of the variables within your dataset
#' @author Luis Valledor and Laura Lamelas
#' @note Mapman annotation files could contain duplicates, importannotation function will ask you how to proceed.
#'
#' @export
#' @importFrom utils select.list read.delim
#' @importFrom readxl excel_sheets read_excel
#' @importFrom stats reshape
#' @importFrom dplyr bind_rows


importannotation <- function() {
  #### Starting console logging ####
  diahora <-gsub(":","",gsub(" ","_", gsub("-","",Sys.time())))
  diahora <-substr(diahora,3,nchar(diahora)-2)
  sinkfilename <- paste(diahora,"_ImportAnnotLog.txt",sep="")
  sink(sinkfilename, split = T)
  #FLAGs ----
  IDENTIFIER <- NULL
  DESCRIPTION <- NULL
  BINCODE <- NULL
  NAME <- NULL
  
  options(warn = -1)
  # Initial texts ----
  headings_wizards("Welcome to pRocessomics annotation parser")
  texts_wizard(
    "\nThis parser will automatically import annotation files generated by Mercator, .txt, (see https://mapman.gabipd.org/app/mercator)."
  )
  texts_wizard("\nCustom annotations following similar scheme can also be imported.")
  texts_wizard("\nAnnotation tables must be in txt, xls, or xlsx format.")
  texts_wizard(
    "\nPlease check pRocessomics documentation available in man pages or check or https://github.com/Valledor/pRocessomics/\n\n"
  )
  texts_wizard("\nPress [enter] to continue...")
  invisible(readline())
  
  # File annotation import ----
  texts_wizard("\nSelect the source of your annotations (write the number) and press [enter]:\n")
  availableparsing <- c("MapMan", "Custom")
  typeofannotation <-
    utils::select.list(
      availableparsing,
      preselect = NULL,
      multiple = F,
      title = NULL,
      graphics = FALSE
    )
  
  
  texts_wizard("\n\nPlease select file with annotations (xls, xlsx, or txt).\n\n")
  readline(prompt="Press [enter] to open the window (note that it can be opened behind this window)")
  annotfilename <- file.choose()
  
  fileextension <- strsplit(annotfilename, "[.]")[[1]]
  fileextension <- fileextension[[length(fileextension)]]
  fileextension <- toupper(fileextension)
  if (!file.exists(annotfilename))
    stop("\n\nIMPORT ERROR: File doesn't exist. Please provide a valid filename to import.\n\n")
  
  if (fileextension %in% c("XLS", "XLSX", "TXT") == F)
    stop("\n\nIMPORT ERROR: File to import must be txt, xlsx or xls.\n\n")
  
    # Mapman ----
  if (typeofannotation == "MapMan") {
    if (fileextension == "TXT") {
      annottable <-
        utils::read.delim(annotfilename, quote = '') #, stringsAsFactors = F)
      annottable <- apply(annottable, 2, function(x)
        gsub("'", "", x))
      annottable <- apply(annottable, 2, function(x)
        gsub("\"", "", x))
      columnames <- toupper(paste(colnames(annottable), collapse = ""))
      if (columnames == c("BINCODENAMEIDENTIFIERDESCRIPTIONTYPE") &&
          annottable[1, 1] == 0) {
        texts_wizard("\nA file produced by Mercator was detected. Starting parsing process")
        annottable <- annottable[, c(3, 4, 1, 2)]
      }
      if (columnames != c("BINCODENAMEIDENTIFIERDESCRIPTIONTYPE") &&
          annottable[1, 1] != 0) {
        texts_wizard(
          "\nThis file does not seem to be generated by Mercator. Please re-run mercator or choose custom annotations when importing.\n\n"
        )
        stop("File not recognized as mercator output")
      }

    }
    
    if (fileextension %in% c("XLS", "XLSX")) {
      sheetnames <- readxl::excel_sheets(annotfilename) #get sheet names
      sheetselection <- sheetnames
      if (length(sheetnames) > 1) {
        texts_wizard(
          "\n\nThe excel file you provided contains more than one sheet. Please select the sheet with annotations and press [enter]: "
        )
        sheetselection <-
          utils::select.list(
            sheetnames,
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
      }
      annottable  <-
        readxl::read_excel(annotfilename, sheet = sheetselection)
      
      if (colnames(annottable) == c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE") &&
          annottable[1, 1] == 0) {
        texts_wizard("\nA file produced by Mercator was detected. Starting parsing process")
        annottable <- annottable[, c(3, 4, 1, 2)]
      }
      if (colnames(annottable) != c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE") &&
          annottable[1, 1] == 0) {
        texts_wizard(
          "\nThis file does not seem to be generated by Mercator. Please re-run mercator or directly imput generated TXT instread Excel file. Alternatively you can choose custom annotations when importing.\n\n"
        )
        stop("File not recognized as mercator output")
      }
    }
    
  }
    # Custom ----
  if (typeofannotation == "Custom") {
    texts_wizard("\nAutomatic parsing is not implemented for custom annotation tables.")
    texts_wizard(
      "\n\nSemi-automatic approach. Annotation tables should have four (4) columns with specific information. Please make sure that at least following columns are available in you data input. You need to have columns with:"
    )
    texts_wizard("\ta: Variable identifier (character);\n")
    texts_wizard("\tb: Variable description (character);\n ")
    texts_wizard("\tc: bin/group/pahtway code (numeric);\n")
    texts_wizard("\td: bin/group/pathway description (character)\n")
    
    if (fileextension == "TXT") {
      annottable <- utils::read.delim(annotfilename)
      annottable <- apply(annottable, 2, function(x)
        gsub("'", "", x))
      annottable <- apply(annottable, 2, function(x)
        gsub("\"", "", x))
      if (colnames(annottable) == c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE") &&
          annottable[1, 1] == 0) {
        texts_wizard("\nA file produced by Mercator was detected. Starting automatic parsing process")
        annottable <- annottable[, c(3, 4, 1, 2)]
        
      }
      if (colnames(annottable) != c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE") &&
          annottable[1, 1] == 0) {
        texts_wizard("\n\nBelow you will find the column names of the input table data.")
        texts_wizard("\nPlease provide answers for the following questions:")
        texts_wizard(
          "\nSelect the number of the column containing variable identifiers and press [enter]: "
        )
        identifier <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing variable descriptions and press [enter]: "
        )
        description <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing group codes (pathways, ...) or group-name references and press [enter]: "
        )
        bincode <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing group name descriptions and press [enter]: "
        )
        name <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        annottable <-
          annottable[, c(identifier, description, bincode, name)]
      }
    }
    if (fileextension %in% c("XLS", "XLSX")) {
      sheetnames <- readxl::excel_sheets(annotfilename) #get sheet names
      sheetselection <- sheetnames
      if (length(sheetnames) > 1) {
        texts_wizard(
          "\n\nThe excel file you provided contains more than one sheet. Please select the sheet with annotations and press [enter]: "
        )
        sheetselection <-
          utils::select.list(
            sheetnames,
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
      }
      annottable  <-
        readxl::read_excel(annotfilename, sheet = sheetselection)
      
      if (all(
        colnames(annottable) == c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE")
      ) && annottable[1, 1] == 0) {
        texts_wizard("\nA file produced by Mercator was detected. Starting parsing process")
        annottable <- annottable[, c(3, 4, 1, 2)]
      }
      if (all(
        colnames(annottable) != c("BINCODE", "NAME", "IDENTIFIER", "DESCRIPTION", "TYPE")
      ) | annottable[1, 1] != 0) {
        texts_wizard("\n\nBelow you will find the column names of the input table data.")
        texts_wizard("\nPlease provide answers for the following questions:")
        texts_wizard(
          "\nSelect the number of the column containing variable identifiers and press [enter]: "
        )
        identifier <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing variable descriptions and press [enter]: "
        )
        description <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing group codes (pathways, ...) or group-name references and press [enter]: "
        )
        bincode <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        texts_wizard(
          "\nSelect the number of the column containing group name descriptions and press [enter]: "
        )
        name <-
          utils::select.list(
            colnames(annottable),
            preselect = NULL,
            multiple = F,
            title = NULL,
            graphics = FALSE
          )
        annottable <-
          annottable[, c(identifier, description, bincode, name)]
      }
    }
    
  }
  
  # List processing ----
  # Firstly all entries without identifier should be removed.
  rowstokeep <- annottable[, 1] != ""
  annottable <- annottable[which(rowstokeep == T), ]
  if(nrow(annottable)==0) {stop("No annotation was imported. Please check the format of the annotation file. It must be either a MapMan output (unmodified) or a table with four columns IDENTIFIER, DESCRIPTION, BINCODE, NAME. Please check wiki for more information.")}
  
  
  # Object name, with some logic behind ----
  
  datalists <- Filter(function(x) "POL" %in% class(get(x)), ls(envir = .GlobalEnv))
  datalists <- c(datalists, Filter(function(x) "pRoDS" %in% class(get(x)), ls(envir = .GlobalEnv)))

  if (length(datalists) == 0) {
    #texts_wizard("\nObject name was not provided by user.\n")
    texts_wizard(
      "\nPlease provide a name for your annotations dataset (not numeric: 123 -> wrong; 123a -> right; a123 -> better) and press [enter]: \n"
    )
    datasetname <- readline()
    if(datasetname==c("")) stop("Exiting. A name for the annotations object must be provided")
    
    if(exists(datasetname)==T){
      texts_wizard("\nNotice that there is an object in global environment with the same name and **it will be replaced**")
      
      texts_wizard("\nDo you want to change this name and provide a unique identifier?")
      rename <- utils::select.list(choices = truefalse)
      if(rename == "Yes") rename <- TRUE
      if(rename == "No") rename <- FALSE
      
      if(rename==TRUE){
       datasetname<-readline("\nPlease provide a new name")
      }
    }
    
    annot.object <- unique(as.data.frame(annottable))
    class(annot.object) <- c("pRoAnnot", "data.frame")
    exportlist <- list(annot.object)
    names(exportlist) <- c(datasetname)
    list2env(exportlist, envir = .GlobalEnv)
    dog <- paste("\nPlease note ",datasetname, " has been saved in your global R enviroment")
    texts_wizard(dog)
    texts_wizard("\nDo you want to export the processed annotations file?")
    answer <- utils::select.list(choices = truefalse)
    if(answer == "Yes"){
      #annot.object <- cbind(rownames(annot.object),annot.object)
      texts_wizard("\nWhich name do you want to assign to annotation file?")
      filename<-readline()
      filename <- paste(filename,".xlsx", sep="")
      writexl::write_xlsx(annot.object, path=filename)
      dog <- paste("Please note ",filename, " has been saved in your working directory:", getwd())
      texts_wizard(dog)
    
    
    return(cat("\nJob finished!\n"))
    
    
    }
  }
  else  {
    texts_wizard("\nWe have detected the following dataset(s) in current environment.Please enter the number of the dataset matching these annotations and press[enter]:")
    datalists <-
      utils::select.list(
        c(datalists, "none of the above"),
        preselect = NULL,
        multiple = F,
        title = NULL,
        graphics = FALSE
      )
    if (datalists == "none of the above") {
      texts_wizard(
        "\nOK, this is a new dataset. Please provide a name for your annotations (not numeric: 123 -> wrong; 123a -> right) and press [enter]: \n"
      )
      datasetname <- readline()
    }
    else{
      datasetname <- paste(datalists, "_annot", sep = "")
      dog <- paste("\nAnnotations were automatically named as \"",
          datasetname, "\".",sep="")
      texts_wizard(dog)
      texts_wizard("\nDo you want to keep this name?")
      nom <- utils::select.list(choices = truefalse)
      
      if (nom == "No") {
        texts_wizard(
          "\nPlease provide a new name for your annotations (not numeric: 123 -> wrong; 123a -> right) and press [enter]: \n"
        )
        datasetname <- readline()
        if(is.null(datasetname)) stop("Exiting. A name must be provided")
        if(datasetname=="") stop("Exiting. A name must be provided")
      }
      #filtering annotations
      texts_wizard(
        "\nAnnotations will be now imported and then filtered. All unnecesary entries will be removed, keeping only those entries corresponding to variables present in the dataset"
      )
      readline("Press [enter] to continue")
      ml <- get(datalists, envir = .GlobalEnv)
      variablenames <- lapply(ml, colnames)
      variablenames <- unname(unlist(variablenames))
      variablenames <- as.data.frame(variablenames)
      variablenames[,2] <- tolower(variablenames[,1])
      annottable <- as.data.frame(annottable)
      annottable[,1] <- tolower(annottable[,1]) #just in case... mapman stops changing names or Custom annotation file
      annottable <-
        subset(
          annottable,
          IDENTIFIER %in% variablenames[,2],
          select = c(IDENTIFIER, DESCRIPTION, BINCODE, NAME)
        )
      colnames(variablenames)<-c("IDENTIFIER","tolower")
      annottable2 <- merge(variablenames,annottable,by.x = "tolower", by.y="IDENTIFIER")
      annottable <-annottable2[,-1]
    }
  }
  # Secondly, we must define duplicates and ask what to do ----
  annottable <- as.data.frame(annottable) #required
  
  # For any reason we have detected exact duplicates (all columns are equal) in Mapman files... 
  # unique(df) will remove only EXACT DUPLICATES
  
  annottable[, 3] <- as.numeric(do.call(rbind, lapply(strsplit(as.vector(annottable[, 3]), "\\."), function(x) x[[1]])))
  annottable[, 4] <- as.character(do.call(rbind, lapply(strsplit(as.vector(annottable[, 4]), "\\."), function(x) x[[1]])))
  
  annottable <- unique(annottable)
  
  #####duplis issues-----
  dupeIds  <- #real dupes <- same variable & different anything (bines or description) mercator4 allows diff F descriptions 
    unique(subset(annottable, duplicated(annottable$IDENTIFIER))$IDENTIFIER)
  
  if (length(dupeIds) != 0) {
    uniqueDF <- subset(annottable,!IDENTIFIER %in% dupeIds)
    dupeDF   <- subset(annottable, IDENTIFIER %in% dupeIds)
    
    
    #descriptions issue 
    dupe_list <- split(dupeDF, dupeDF$IDENTIFIER)
    #des.issue <- lapply(dupe_list, function(x) length(unique(x[,2])))
    des.issue <- lapply(dupe_list, function(x) cbind("IDENTIFIER"=x[,1],
                                                     #"DESCRIPTION"=c(rep(x[1,2],nrow(x))), #first description
                                                     "DESCRIPTION"=c(rep(x[which(nchar(x[,2])==min(nchar(x[,2])))[1],2],nrow(x))), #shortest description
                                                     "BINCODE"=x[,3], 
                                                     "NAME"=x[,4])) 
    des.issue <- lapply(des.issue, function(x) unique(x))
    des.issue.solved <- as.data.frame(do.call(rbind, des.issue))
    
    annottable <- as.data.frame(rbind(uniqueDF, des.issue.solved))
    dupeIds  <- #real dupes <- same variable & different bins
      unique(subset(annottable, duplicated(annottable$IDENTIFIER))$IDENTIFIER)
    
  }
  if (length(dupeIds) != 0) {
    uniqueDF <- subset(annottable,!IDENTIFIER %in% dupeIds)
    dupeDF   <- subset(annottable, IDENTIFIER %in% dupeIds)
    auxindex <- unique(dupeDF[, 1])
    dog <-
      (paste(
        "\nWe have detected",
        length(auxindex),
        "duplicated cases in your annotation table"
      ))
    texts_wizard(dog)
    
    texts_wizard("Do you want to manually choose each annonation (Yes) or keep duplicates (No)?")
    manual <-
      utils::select.list(choices = truefalse)
    if (manual == "Yes") {
      if (length(auxindex) > 50) {
        dog <- (paste(
          "\nUmmm,",
          length(auxindex),
          "duplicated cases, that's quite a lot!"
        ))
        texts_wizard(dog)
        texts_wizard("Are you SURE that do you want to MANUALLY ASSESS each duplicated case (Yes) or you prefer to keep duplicates (No)?")
        manual <- utils::select.list(choices = truefalse)
        
      }
    }
    
    if (manual == "No"){
      texts_wizard("keeping duplicates")
      manual <- FALSE
    }
    if (manual == "Yes") {
      #uniq_aux <- c()
      for (i in 1:length(auxindex)) {
        eachobject <- subset(dupeDF, IDENTIFIER %in% auxindex[i])
        
        say <-
          (
            paste(
              "\n Please enter the desired Mapman category(-ies) for",
              auxindex[i],
              "with description:\n",
              unique(eachobject[, 2]),
              "\n", sep = " "
            )
          )
        texts_wizard(say)
        
        annot.choices <- paste(eachobject[, 3], eachobject[, 4], sep = "|")
        uniq <-
          as.vector(
            select.list.edit(
              annot.choices,
              preselect = NULL,
              multiple = T,
              title = NULL,
              graphics = FALSE
            )
          )
        if (length(uniq) == length(annot.choices)){
          uniqueDF <- rbind(uniqueDF, eachobject) # unique is not unique anymore
        }
        else {
          selectedbin <- as.vector(data.frame(do.call(rbind, strsplit(
            as.character(uniq), '|', fixed = T)))[,1])
          almost <- subset(eachobject, BINCODE %in% selectedbin)
          uniqueDF <- rbind(uniqueDF, almost)
        }
      }
      annottable <- uniqueDF # User reviewed annottable
    }
    dupeIds  <- #new dupes <- same variable & different bines
      unique(subset(annottable, duplicated(annottable$IDENTIFIER))$IDENTIFIER)
    
    if (length( dupeIds) != 0){
      uniqueDF <- subset(annottable,!IDENTIFIER %in% dupeIds)
      dupeDF   <- subset(annottable, IDENTIFIER %in% dupeIds)
      auxindex <- unique(dupeDF[, 1])
      
      annot.object <- c()
      for (i in 1:length(auxindex)) {
        eachobject <- subset(dupeDF, IDENTIFIER == auxindex[i])
        eachobject$id <- 1
        eachobject$number <- seq(1:nrow(eachobject))
        eachobject_row <-
          stats::reshape(
            as.data.frame(eachobject[, 3:ncol(eachobject)]),
            direction = "wide",
            idvar = "id",
            timevar = "number"
          )
        final <-
          cbind(
            IDENTIFIER = eachobject$IDENTIFIER[1],
            DESCRIPTION = eachobject$DESCRIPTION[1],
            eachobject_row
          )
        final <- final[, -3]
        annot.object <- dplyr::bind_rows(annot.object, final)
      }
      colnames(uniqueDF) <-
        c("IDENTIFIER", "DESCRIPTION", "BINCODE.1", "NAME.1")
      annot.object <- dplyr::bind_rows(annot.object, uniqueDF)
    }
  }
  if (length(dupeIds) == 0) {
    annot.object <- annottable
  }
  #annot.object <- lapply(annottable, as.vector)
  #annot.object <- as.data.frame(do.call(cbind, annottable))
  
  annot.object <- as.data.frame(annot.object)
  bincodeaux <- seq(from = 3, to = ncol(annot.object), by = 2)
  
  for(i in bincodeaux){
    annot.object[,i] <- as.numeric(as.character(annot.object[,i]))}
  
  
  class(annot.object) <- c("pRoAnnot", "data.frame")
  exportlist <- list(annot.object)
  names(exportlist) <- c(datasetname)
  list2env(exportlist, envir = .GlobalEnv)
  
  dog <- paste("\nPlease note that \"",datasetname,"\" has been saved in global enviroment", sep="")
  texts_wizard(dog)
  texts_wizard("\nDo you want to export the filtered annotations to a .xlsx file?")
  answer <- utils::select.list(choices = truefalse)
  if(answer == "Yes"){
    #annot.object <- cbind(rownames(annot.object),annot.object)
    texts_wizard("\nPlease provide a name for annotation file (without extension) and press [enter]")
    filename<-readline()
    filename <- paste(filename,".xlsx", sep="")
    writexl::write_xlsx(annot.object, path=filename)
    dog <- paste("\"",filename,"\" has been saved in your working directory:", getwd())
    texts_wizard(dog)
  }

  #### Exporting session log ####
  texts_wizard("\nimportannotation: Duty Accomplished.")
  dog <- as.character(paste("Session log, ",sinkfilename, " has been saved in your working directory: ", getwd(),sep=""))
  texts_wizard(dog)
  sink()
  
  
}
